HDR实现的一般步骤：
    a：使用每个颜色通道都是16位或者32位的浮点纹理或者渲染目标渲染当前的场景；
    b：使用RGBM、LogLuv等编码方式来节省所需的内存和带宽；
    c：通过降采样计算场景亮度；
    d：根据场景亮度值对场景做一个色调映射，将最终颜色值输出到一个每通道8位的RGB格式的渲染目标上。

光照贴图之定向光照贴图：
光照贴图目前用得比较多而且渲染效果也不错的实现方法是定向光照贴图（directional light map），
它是原始光照贴图的增强实现。它主要是通过在预处理与实时还原过程中加入场景中表面的法向量进行运算，
进而增强效果。定向光照贴图技术的大致实现方式如下所示。
1）在采样点处把其所处的半球空间中的辐射入射度用某种方法进行采集并保存。
2）以某种方法存储额外的且与该辐射入射度相关的法线信息到烘焙所得的光照贴图中。
3）在运行时的实时渲染过程中，通过光照贴图对片元上的场景辐射入射度，并结合光照信息和方向信息进行还原。

相关方法：UnityCG.cginc  DecodeDirectionalLightmap


// ********** 前向渲染和延迟渲染 **********
顶点着色器 -> 片元着色器 -> 模板测试 -> 深度测试

前向渲染：
做法：
    在顶点着色器中对所有待渲染对象的顶点进行一系列的变换，这些变换通常是将顶点的法线和位置变换到裁剪空间。
    如果采用逐片元光照（per-fragment lighting）的方式，在渲染每一帧时，每个片元都要执行一次片元着色器代码，
    这时需要将所有的光照信息都传递到片元着色器中。
    虽然在大部分情况下的光源都【趋向于小型化】，而且其照亮的区域也不大，但即便是光源离这个像素所对应的世界空间
    中的位置很远，但当片元着色器中计算光照时，还是【会把所有的光源】都考虑进去。
性能缺陷：
    1、不能很好的支持场景中存在的大量的光源，光源数量多时，片元着色器要做的运算量会很大。
    2、如果渲染的场景十分复杂，里面包含了大量的待渲染对象，将不可避免的产生【在屏幕中同一像素中，其实会被多个
    物体所对应覆盖】的情况，即有很大的深度复杂度时，我们会浪费很多GPU资源。
理解：
    对于每个物体、每个光源，都会执行一次完整的顶点、片元计算过程。（在光栅化阶段被裁剪空间裁剪掉的不会进行片元着色器）
    （疑问，这里顶点着色器其实是只需要执行一次，然后在片元着色器中执行多次光照计算，实际前向渲染中应该就是也只执行一次，
    所以才会说，光源数量多时，片元着色器要做的运算量会很大）。
    物体的最终的颜色是：每个光源的渲染结果，经过模板、深度测试后的复合结果（相加吧？）
    所以对于那些不能经过模板、深度测试的光照计算都是无用的。

延迟渲染：
关键思想：
    把大部分光照计算等计算量很大的操作，延迟或推迟到尽可能后的阶段中进行。
做法：
    与在前向渲染中总是将所有的待渲染对象从顶点缓冲区一路线性地渲染到最后的颜色缓冲区的流程不同，
    延迟渲染将这个过程拆分成了【两个处理通路（pass）】。
第一个通路：几何处理通路
    在此处理通路中，首先将场景渲染一次，获取到待渲染对象的各种几何信息，如位置向量、颜色向量、法线向量、深度值等，
    并且会把这些几何信息存储到名为几何缓冲区（geometry buffer），即 G-buffer 缓冲区中，这些缓冲区将会在之后用作更复杂的光照计算。
    由于有深度测试，所以最终写入 G-buffer 中的各个数据都是离摄像机最近的片元的几何属性，这意味着所有不会出现在最后
    屏幕上的片元都在深度测试中被丢弃，最后会被留在 G-buffer 中的片元都是必定要进行光照计算的。
第二个通路：光照处理通路
    遍历所有 G-buffer 中的每一纹素，使用纹素中保存的光照信息，在与屏幕大小相等的矩形图元上执行一次光照计算即可。
性能：
    延迟渲染可以不需要消耗大量的性能去执行光照计算，但它本身并不能支持非常大量的光照计算。
理解：
    在几何处理通路中，就是正常渲染整个场景，利用深度测试，得到离摄像机最近的片元的几何属性，写入GBuffer。
    然后在光照处理通路中，采样GBuffer中的片元的几何信息，对每个片元执行一次光照计算，但这里的一次仍会处理每个光源对片元的最终影响。
    所以总的来说，延迟渲染，只是消除了前向渲染中，深度复杂度高时的无用功部分带来的影响，并不能非常大量的光源数量的光照计算。


// ********** Unity中支持的渲染路径 **********
1、延迟渲染途径具有光照和阴影效果的保真度最高特点，如果场景中有大量的实时光源，且硬件性能足以支持，则使用这种途径最为合适。
2、前向渲染途径是引擎默认使用的渲染途径，此渲染途径支持所有典型的图形功能，如法线贴图、逐像素光照、阴影等。但是在默认设置下，
即使指定使用逐片元光照模式进行光照计算，前向渲染途径中也仅仅是少数光源会使用逐片元光照模式，其余光源则是逐顶点计算的。
3、旧式延迟渲染途径类似于延迟渲染途径，只是使用不同的技术实现。旧式延迟渲染途径不支持基于物理渲染（physically based rendering）
的标准着色器（standard shader）。
4、旧式顶点照明途径是一种光照效果保真度最低的渲染途径，此途径不支持实时阴影，可以认为它是前向渲染途径的一个子集。


// ********** 前向渲染路径的实现细节 **********
    在前向渲染途径中，若干个最亮的且能照亮每个物体的光源执行逐片元光照计算。
    剩下的光源中，最多 4 个点光源执行逐顶点光照计算，剩下的光源则以球面调谐（spherical harmonics）的方式计算光照。
如何决定一个光源是否以逐片元光照模式去计算光照效果？
    Light组件中，RenderMode的设置（Not Important、Important、Auto）
    Quality Setting面板中Pixel Light Count的数量设置。

前向渲染的渲染通路有两种：基本通路、附加通路
基本通路（做的事情）：
    对默认的那一个有向平行光（最亮的那个吧），进行逐片元的光照计算，（并且在此光源的Shadow Type属性为Soft Shadows或者Hard Shadows时，
    将会启动阴影效果）；
    计算按照逐顶点光照处理的所有光源的光照效果；
    计算按照球谐光照处理的所有光源的光照效果；
    计算物体的自发光；
    计算环境光（光照贴图？）；
注意：
    1、在基本通路中，如果启用了 OnlyDirectional 标识符，则只对默认的有向平行光光源、环境光、光探针和光照贴图进行计算，
    原本在基本通路中计算的顶点光照和球谐光照不再计算。
    2、除了设置 LightMode 为 ForwardBase 之外，还需要使用编译指示符 multi_compile_fwdbase 指令。只有启用此指令，
    才会激活基本通路中进行光照计算所需要的一些宏，如光照衰减值等
附加通路（做的事情）：
    计算其他逐片元光照处理的光源的光照效果，每个光源执行一次。
注意：
    1、需要把 LightMode 的类型指定为 ForwardAdd，还要启用 multi_compile_fwdadd 编译指示符相关的宏、变量和函数。
    2、默认地其他通路是没有阴影效果的，即使光源的 Light 组件中 Shadow Type 属性设置为 Soft Shadows 或者 Hard Shadows
     也是没有效果的。要使用阴影效果，就需要把 mulit_compile_fwdadd 指示符改为 multi_compile_fwdadd_fullshadows，
     才能令点光源和聚光灯光源开启阴影效果。
     3、需要设置混合模式，一般采用 Blend One One。


// ********** 延迟渲染路径的实现细节 **********
    Unity 3D 支持两种延迟渲染途径，即 5.0 版本之前的旧式延迟渲染途径和 5.0 及之后版本的延迟渲染途径。
    两者的差异不大，主要区别是【旧式】延迟渲染途径【不支持】基于物理渲染的标准着色器。
    延迟渲染中实时光源的渲染开销与该光源所能照射到的像素数成正比，而与场景本身的复杂度无关。
优点：
    1、能够对待渲染物体进行照明的光源格式在理论上是无限的；（怎么理解？光源格式指平行光、点光源、聚光灯这种？）
    2、所有的光源都执行逐片元光照，因此所有光源都能使用 cookie 纹理和产生阴影，在光照计算中可以使用诸如法线贴图等【逐片元光照技术】。
缺点：
    1、不支持真正的反走样（anti-aliasing，也叫抗锯齿吧）功能。
    2、无法处理半透明物体的渲染。（很好理解 -> 先深度剔除后，再计算的光照）
    3、对显卡的性能有较高要求，显卡必须支持多渲染目标功能（MRT -> 作用是：将每个像素的数据保存到不同的缓冲区当中），
    必须使用shader model 3.0及以上版本，必须支持深度纹理和双面模板缓冲。
    4、如果执行延迟渲染的摄像机是正交的，则摄像机执行的渲染途径将会退回（fall back）到使用前向渲染途径。
几何处理通路：
    --> 对应于 -> "LightMode" = "Deferred" 的Pass
光照处理通路：
    --> 对于Standard.shader来说，我觉得应该是对应于 ->  "LightMode"="Meta" 的Pass


// ********** Unity 3D 的全局光照和阴影 **********

// ********** 全局照明和局部照明 **********
全局照明（GI）：
    向三维向量场景中添加更为逼真的光照效果的一组算法的总称。
    全局照明算法不仅考虑光源发出的光与被照亮物体之间的关系，即直接照明（direct illumination），
    还考虑光线从某一物体的表面传递到另一个物体的表面时的关系，即间接照明（indirect illumination）。

局部照明：
    只考虑直接照明，不考虑光线在物体之间的反射。
    
光线追踪（ray tracing）：
    该技术通过跟踪场景中的光线传播的轨迹路径来模拟真实世界中的景象，是一种很适合实现全局照明的方法。
    渲染速度太慢，不适合实时渲染。

// ********** 全局照明解决方案 **********
烘培式全局照明（baked GI）或者叫烘焙式光照贴图（baked lightmapping）：
    只能应用到静态物体上。
    只为场景中静止不动的物体预先针对间接照明进行计算，并把计算结果存储起来，然后在运行时使用这些间接光照信息进行渲染。
    烘焙式全局光照可以利用更多的预计算时间支持使用【区域面光源（area light）】（？？）产生的光照效果，以及支持更加逼真柔和的阴影。

预计算实时全局照明（precomputed realtime GI）：
    Unity5.0增加，依然应用在静态物体上。
    在预计算阶段，除了计算出【当前光源发出的光线，沿着当前的传播路径照亮到本物体时的效果】，
    还要处理【如果在运行时有光线沿着别的传播路径传递到本物体表面时，光线应该沿着那个方向传递出去】的问题。
    -->>
    引擎在预计算阶段会计算所有可能的【光线传播路径】并存储，（所有可能的路径？，路径是哪儿到哪儿的路径？）
    在运行时，将当前的光源输入预计算的光传播途径中，并计算光照效果。
    -->>
    由于存储的是传播路径，因此使用预计算实时全局照明技术在运行时，光源的数量、类型、位置等属性都可以改变。
    被照亮物体的材料属性，如吸收光的能力、自己发射光的能力也可以改变。
    在运行时，间接照明的效果也会相应更新这一切只要保持物体是静态的且形状不发生改变即可。
    -->>
    能产生较为柔和的阴影，但是除非场景很小，否则这些阴影会比烘焙式全局照明所产生的阴影要粗糙些。
    预计算实时全局照明是在运行时才执行最终的光照计算的，引擎将光照算法进行了优化。
    如果光源或者被照亮物体的相关属性相比预计算阶段发生了很剧烈的变化，则会需要更多的时间计算最终的光照效果。

上述两种解决方案存在的问题：
    只能运用在静态物体上，移动的物体【无法将光线反射到其他物体上】，其他物体也无法将光线反射到移动的物体上。
    【光照探针】就是用来解决这个问题的。
    疑问，对于预计算的实时全局照明，路径里面不是保存了全局光照信息了吗，为什么还要使用光照探针拾取光照信息呢？

光照探针：
    场景中的某个位置点，在烘培或者预计算阶段，在该位置上测量或者探测光线，并在此记录下相关的光照信息，
    在运行时，运动的物体将从离它最近的光照探针中取出间接光照信息并使用上。
    疑问，这里解决的【动态物体无法反射和接受反射的问题】？拿到光照探针里的信息，再重新对动态物体实时计算反射光？不可能吧。

在Unity中设置光照的解决方案：
    1、选择Window|Lighting|Setting命令，在弹出的Lighting窗口中设置好各项对应的属性；
    2、给各光源的Light组件设置合适的Mode属性（Realtime、Mixed、Baked）。

区域面光源：
    照明计算相当耗费性能，不支持实时进行光照计算，只能预先烘焙到光照贴图中。

// ********** 光源光照模式与全局照明 **********

// ********** 实时模式光源进行全局光照 **********
    Ligth组件的Mode属性设置Realtime的光源被称为实时模式光源。
    实时是指在每一帧中，这些光源都直接为引擎提供光照计算所需要的参数，引擎计算出当前场景的光照效果。
    ->
    默认的，实时模式光源只产生直接照明，不产生间接照明。
    -->>
    我们可以通过，选择Window|Lighting|Settings命令，在弹出的Lighting窗口中把Sence选项卡的Realtime Lighting
    项的Realtime Global Illumination复选框选中，来支持实时全局照明。
    上述复选框选中后，场景内所有的Real Time模式光源发出的光线同时能执行直接照明和间接照明，（怎么执行的逻辑写在哪里？）
    可通过将光源的 Light 组件中的 Indirectional Multiplier 属性设置为 0，来禁用某个光源的间接照明。
    --->>>
    实时全局照明的光照计算方式，适用于位置、强度变化缓慢的光源。
    ---->>>>
    耗费大量的系统资源，仅适合中高度PC或者主机平台。

【Realtime Lighitng|Realtime Global Illumination 复选框被选中时，Unity做了什么？】
    即预计算的实时全局光照做了什么？
    1、使用Enlighten引擎为静态物体预计算它们之间的外表面到外表面的光线传递路径，并保存成【光照数据资源（lighting data asset）】，
    （这句话是根据文章上下文，自己得出猜测的，猜测文中光照效果就是光线传递路径）
    2、Unity 3D在运行时，根据这些光照数据资源文件，实时地产生和更新一组低分辨率的光照贴图，
    从而实现单纯用烘焙式光照贴图无法达成的动态光照效果。
    （实时生成的低分辨率的光照贴图中包括了什么信息？路径？还是最终的光照结果？最终是怎么实现的动态光照效果？
    个人猜测1：
    低分辨率光照贴图就是根据场景的所有物体（包括动态和静态），以及预计算的光线路径，实时计算的光照效果，也就是最终的光照效果
    个人猜测2：
    低分辨率光照贴图是调整更新后的光照路径，最终的光照效果需要根据这些路径，对场景所有的物体（动态和静态）进行计算）

【效果】    
    可以照亮静止和运动的游戏对象（包含间接光照），
    投影逼真的阴影（阴影显示与否与阴影相关的设置也有关系）。
阴影：
    如果光源能投射阴影，场景中动态和静态游戏对象所对应的深度信息都将被渲染成阴影贴图，
    着色器会采样这个阴影贴图，实现物体互相投射实时阴影的效果。
    （猜测：这里的阴影贴图实现起来应该比较麻烦，应该要总和考虑所有的光照路径来判断最终的片元是否在阴影中）


// ********** 使用烘焙式光照贴图进行全局照明 **********
    Ligth组件的Mode属性设置Baked的光源被称为烘焙模式光源。
    ->
    Unity在运行前预先计算这些光源产生的直接照明和间接照明信息，烘焙到光照贴图或者光探针上。
    -->>
    静态物体表面的颜色烘焙到光照贴图；
    用以照亮动态物体的照明信息烘焙到光探针；
    --->>>
    因为光照信息预计算，故不能产生镜面反射（这里应该是不能对动态物体产生镜面反射吧）；
    光照贴图，可以存储静止的游戏对象投射到静止的游戏对象的阴影，运行时直接使用不用再计算；
    烘焙模式光源下的运动物体，无法向另一个（任何类型）的物体投射阴影；
    被烘焙模式光源照射的静止的游戏物体，可以投射较低分辨率的阴影到运动的游戏对象上，但要借助光探针才能达成这种效果。
    ---->>>>
    烘焙式贴图运行期是不可改变的；
    场景中的物体使用烘焙式贴图时，也可以使用实时光源，以颜色叠加的方式作用在它上面；

（！！！一个异常抽象的问题：预计算的实时全局光照和光探针有什么本质的区别？？？
光照探针的光照信息运行时不会改变，但是预计算实时全局光照的路径会改变？）


// ********** 使用混合光照进行全局照明 **********
    Ligth组件的Mode属性设置Mixed的光源被称为混合模式光源。
    混合模式光源，可以在运行时改变其位置、朝向、大小、光的颜色和强度等属性，这些改变有较大限制。
    ->
    可以照亮静止和运动的游戏对象，并且一直贡献直接照明，按选择提供间接照明；（怎么选择？？见下面的混合光照模式）
    被照射的运动物体，总是能在其他运动物体上投射实时阴影；（如何投影的？？见下面的混合光照模式）
    -->>
    场景中所有混合模式的光源使用同一种【混合光照模式】；
    【混合光照模式】在Light Setting窗口 Mixed|Lighting Mode下拉框中设置；
    Lighting Mode 子选项有 3 种，它们分别是 Baked Indirect、Shadowmask、Subtractive。
    --->>>
    如果一个光源本身并不需要参与游戏的相关逻辑（日升日落？），那么它可以考虑设置成混合模式的光源。
    因为由混合模式光源提供的【直接照明是在运行时计算】，所以静止的游戏对象将会在最大程度上保持预期的视觉效果。（不理解！！）

【Baked Indirect混合光照模式】
    Unity 3D 仅对光源提供的【间接照明部分进行预计算】（所有的预计算应该都是只能针对静态物体）。
    而所有离当前摄像机的距离小于 Shadow Distance 值的阴影，都是在运行时实时计算。
    ->
    所有距离当前摄像机距离小于Shadow Distance 的任何物体，都能对其他任何物体互相投射阴影，
    大于Shadow Distance的任何物体都无法向其他物体投射阴影。



光探针照明的大致原理是：在某一光探针（light probe）的所在位置点上对光照信息进行采样，
然后从该光探针相邻的其他光探针的位置上对光照信息进行采样，把这些采样得到的光照信息进行插值运算，
便可算出这些光探针之间的某个位置的光照信息。